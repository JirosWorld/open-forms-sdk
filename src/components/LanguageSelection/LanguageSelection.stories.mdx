import {useState} from 'react';
import { Meta, Canvas, Story, ArgsTable } from '@storybook/addon-docs';
import { within, userEvent, waitFor } from '@storybook/testing-library';
import { expect } from '@storybook/jest';
import { rest } from 'msw';
import { IntlProvider } from 'react-intl';
import { getWorker } from 'msw-storybook-addon';

import { ConfigContext } from 'Context';
import ErrorBoundary from 'components/ErrorBoundary';
import { I18NContext } from 'i18n';

import { LanguageSelection, LanguageSelectionDisplay } from '.';
import { BASE_URL, DEFAULT_LANGUAGES, mockLanguageInfoGet, mockLanguageChoicePut, mockInvalidLanguageChoicePut } from './mocks';

export const ConfigDecorator = (Story, { args }) => (
  <ConfigContext.Provider value={{ baseUrl: args.baseUrl || BASE_URL }}>
    <I18NContext.Provider value={{
      languageSelectorTarget: null,
      onLanguageChangeDone: args.onLanguageChangeDone,
    }}>
      <Story />
    </I18NContext.Provider>
  </ConfigContext.Provider>
);

export const worker = getWorker();

<Meta
  title="Composites/Language Selection"
  component={LanguageSelection}
  argTypes={{
    heading: {
      control: 'text',
      table: {
        type: { summary: 'string' },
      },
    },
    headingLevel: {
      control: { type: 'number', min: 1, max: 6 },
      table: {
        type: { summary: 'number' },
      },
    },
    onLanguageChange: { action: true },
    onLanguageChangeDone: {
      action: true,
      table: { disable: true }
    },
  }}
  parameters={{
    msw: {
      handlers: [mockLanguageChoicePut],
    }
  }}
/>

# Language selection

The language selection allows end-user to switch between available languages, as supported
by the backend.

This functionality is split in two components - one purely for display and
styling purposes and the other one with smart behaviour to fetch the data
from the backend.

## Presentation

The `LanguageSelectionDisplay` component presents the available languages and
dispatches events when the user changes the active language.

export const DisplayTemplate = (args) => <LanguageSelectionDisplay {...args} />;

<Canvas>
  <Story
    name="Display"
    args={{
      heading: 'Language selection',
      headingLevel: 2,
      headingId: 'heading-id',
      items: [
        {
          lang: 'en',
          textContent: 'EN',
          label: 'English',
          current: true,
        },
        {
          lang: 'nl',
          textContent: 'NL',
          label: 'Nederlands',
          current: false,
        },
        {
          lang: 'fy',
          textContent: 'FY',
          label: 'frysk',
          current: false,
        },
      ],
    }}
    play={async ({ args, canvasElement }) => {
      const canvas = within(canvasElement);
      await userEvent.click(canvas.getByText(/^fy$/i));
      await expect(args.onLanguageChange).toHaveBeenCalled();
    }}
  >
    {DisplayTemplate.bind({})}
  </Story>
</Canvas>

### Props

<ArgsTable of={LanguageSelectionDisplay} />

## Functional

The functional component handles the "smart" behaviour:

* Fetch available languages from the backend
* Read the preferred language via the backend and the HTTP `Accept-Language` header
* Handle the user language-changed events and propagate them up the component tree

It is responsible for rendering the `LanguageSelectionDisplay` component.

export const Template = (args) => {
  worker.use(mockLanguageInfoGet(args.languages));
  return (
    <IntlProvider messages={{}} locale={'nl'} defaultLocale="nl">
      {
        args.wrapInErrorBoundary
          ? (
            <ErrorBoundary>
              <LanguageSelection {...args} />
            </ErrorBoundary>
          )
          : <LanguageSelection {...args} />
      }
    </IntlProvider>
  );
};

<Canvas>
  <Story
    name="Functional"
    decorators={[ConfigDecorator]}
    parameters={{
      controls: { expanded: true },
      docs: {
        source: {
          type: 'dynamic',
          excludeDecorators: true,
        }
      }
    }}
    args={{
      baseUrl: process.env.REACT_APP_BASE_API_URL || BASE_URL,
      languages: DEFAULT_LANGUAGES,
    }}
    argTypes={{
      baseUrl: {
        description: '`string`, used when the mocks are disabled and passed to the config context.',
      }
    }}
    play={async ({args, canvasElement}) => {
      const canvas = within(canvasElement);
      // wait for api info call to return
      let frysk_button = await waitFor(() => canvas.findByText(/^fy$/i));
      window.confirm = () => true;
      await userEvent.click(frysk_button);
      // wait for PUT api call to have completed and loading state to be resolved
      await waitFor(() => canvas.findByText(/^fy$/i));
      await expect(args.onLanguageChangeDone).toHaveBeenCalledTimes(1); // change once
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

Note that you can modify the `baseUrl` arg in the canvas to make live requests if you disable the
mock responses in the mock panel.

### Props

<ArgsTable of={LanguageSelection} />

### Errors

Errors are left to bubble up to the nearest `ErrorBoundary`, e.g. if for some reason the language is unavailable a `ValidationError` is returned from the API:

<Canvas>
  <Story
    name="Unavailable language"
    decorators={[ConfigDecorator]}
    args={{
      wrapInErrorBoundary: true,
      languages: DEFAULT_LANGUAGES,
    }}
    argTypes={{
      heading: { table: { disable: true } },
      headingLevel: { table: { disable: true } },
    }}
    parameters={{
      msw: {
        handlers: [
          mockInvalidLanguageChoicePut('fy'),
        ],
      },
      docs: {
        source: {
          type: 'dynamic',
          excludeDecorators: true,
        }
      }
    }}
    play={async ({args, canvasElement}) => {
      const canvas = within(canvasElement);
      const frysk_button = await waitFor(() => canvas.findByText(/^fy$/i)); // wait for api info call to return
      window.confirm = () => true;
      await userEvent.click(frysk_button);
      await waitFor(() => expect(args.onLanguageChangeDone).toHaveBeenCalledTimes(0)); // did not change language
    }}
  >{Template.bind({})}</Story>
</Canvas>
