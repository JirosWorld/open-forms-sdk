import {ArgsTable, Canvas, Meta, Story} from '@storybook/addon-docs';
import {expect} from '@storybook/jest';
import {userEvent, waitFor, within} from '@storybook/testing-library';
import {rest} from 'msw';
import {getWorker} from 'msw-storybook-addon';
import {useState} from 'react';
import {IntlProvider} from 'react-intl';

import {ConfigContext} from 'Context';
import ErrorBoundary from 'components/ErrorBoundary';
import {I18NContext} from 'i18n';
import {ConfigDecorator} from 'story-utils/decorators';
import {BASE_URL} from 'story-utils/mocks';

import {LanguageSelection, LanguageSelectionDisplay} from '.';
import {
  DEFAULT_LANGUAGES,
  mockInvalidLanguageChoicePut,
  mockLanguageChoicePut,
  mockLanguageInfoGet,
} from './mocks';

export const I18NDecorator = (Story, {args}) => (
  <I18NContext.Provider
    value={{
      languageSelectorTarget: null,
      onLanguageChangeDone: args.onLanguageChangeDone,
    }}
  >
    <Story />
  </I18NContext.Provider>
);

export const worker = getWorker();

<Meta
  title="Composites/Language Selection"
  component={LanguageSelection}
  decorators={[I18NDecorator, ConfigDecorator]}
  argTypes={{
    heading: {
      control: 'text',
      table: {
        type: {summary: 'string'},
      },
    },
    headingLevel: {
      control: {type: 'number', min: 1, max: 6},
      table: {
        type: {summary: 'number'},
      },
    },
    onLanguageChange: {action: true},
    onLanguageChangeDone: {
      action: true,
      table: {disable: true},
    },
  }}
  parameters={{
    msw: {
      handlers: [mockLanguageChoicePut],
    },
  }}
/>

# Language selection

The language selection allows end-user to switch between available languages, as supported by the
backend.

This functionality is split in two components - one purely for display and styling purposes and the
other one with smart behaviour to fetch the data from the backend.

## Presentation

The `LanguageSelectionDisplay` component presents the available languages and dispatches events when
the user changes the active language.

export const DisplayTemplate = args => <LanguageSelectionDisplay {...args} />;

<Canvas>
  <Story
    name="Display"
    args={{
      heading: 'Language selection',
      headingLevel: 2,
      headingId: 'heading-id',
      items: [
        {
          lang: 'en',
          textContent: 'EN',
          label: 'English',
          current: true,
        },
        {
          lang: 'nl',
          textContent: 'NL',
          label: 'Nederlands',
          current: false,
        },
        {
          lang: 'fy',
          textContent: 'FY',
          label: 'frysk',
          current: false,
        },
      ],
    }}
    play={async ({args, canvasElement}) => {
      const canvas = within(canvasElement);
      await userEvent.click(canvas.getByText(/^fy$/i));
      await expect(args.onLanguageChange).toHaveBeenCalled();
    }}
  >
    {DisplayTemplate.bind({})}
  </Story>
</Canvas>

### Props

<ArgsTable of={LanguageSelectionDisplay} />

## Functional

The functional component handles the "smart" behaviour:

- Fetch available languages from the backend
- Read the preferred language via the backend and the HTTP `Accept-Language` header
- Handle the user language-changed events and propagate them up the component tree

It is responsible for rendering the `LanguageSelectionDisplay` component.

export const Template = args => {
  worker.use(mockLanguageInfoGet(args.languages));
  return (
    <IntlProvider messages={{}} locale={'nl'} defaultLocale="nl">
      {args.wrapInErrorBoundary ? (
        <ErrorBoundary>
          <LanguageSelection {...args} />
        </ErrorBoundary>
      ) : (
        <LanguageSelection {...args} />
      )}
    </IntlProvider>
  );
};

<Canvas>
  <Story
    name="Functional"
    parameters={{
      controls: {expanded: true},
      docs: {
        source: {
          type: 'dynamic',
          excludeDecorators: true,
        },
      },
    }}
    args={{
      languages: DEFAULT_LANGUAGES,
    }}
    play={async ({args, canvasElement}) => {
      const canvas = within(canvasElement);
      // wait for api info call to return
      let frysk_button = await waitFor(() => canvas.findByText(/^fy$/i));
      window.confirm = () => true;
      await userEvent.click(frysk_button);
      // wait for PUT api call to have completed and loading state to be resolved
      await waitFor(() => canvas.findByText(/^fy$/i));
      await expect(args.onLanguageChangeDone).toHaveBeenCalledTimes(1); // change once
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

### Props

<ArgsTable of={LanguageSelection} />

### Errors

Errors are left to bubble up to the nearest `ErrorBoundary`, e.g. if for some reason the language is
unavailable a `ValidationError` is returned from the API:

<Canvas>
  <Story
    name="Unavailable language"
    args={{
      wrapInErrorBoundary: true,
      languages: DEFAULT_LANGUAGES,
    }}
    argTypes={{
      heading: {table: {disable: true}},
      headingLevel: {table: {disable: true}},
    }}
    parameters={{
      msw: {
        handlers: [mockInvalidLanguageChoicePut('fy')],
      },
      docs: {
        source: {
          type: 'dynamic',
          excludeDecorators: true,
        },
      },
    }}
    play={async ({args, canvasElement}) => {
      const canvas = within(canvasElement);
      const frysk_button = await waitFor(() => canvas.findByText(/^fy$/i)); // wait for api info call to return
      window.confirm = () => true;
      await userEvent.click(frysk_button);
      await waitFor(() => expect(args.onLanguageChangeDone).toHaveBeenCalledTimes(0)); // did not change language
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>
