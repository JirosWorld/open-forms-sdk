import {ArgsTable, Canvas, Meta, Story} from '@storybook/addon-docs';
import {expect} from '@storybook/jest';
import {userEvent, within} from '@storybook/testing-library';
import {addDays, subDays} from 'date-fns';

import {ConfigDecorator, FormikDecorator} from 'story-utils/decorators';

import DateField from './DateField';

export const Template = args => <DateField {...args} />;

<Meta
  title="Pure React Components / Forms / DateField"
  component={DateField}
  decorators={[FormikDecorator]}
  parameters={{
    docs: {
      source: {
        type: 'dynamic',
        excludeDecorators: true,
      },
    },
    formik: {
      initialValues: {
        test: '',
      },
    },
  }}
/>

## Date field

We identify different types of date inputs, each coming with their most-appropriate UI element.

**Nearby dates**

Think of appointment dates, booking dates and similar. Here, the expected date is in the nearby
future or past. A calendar component is appropriate because:

- you can display occupied dates and/or date ranges
- you can indicate the current date
- it is not expected that the user needs to click the year/month button too many times

**Known dates (currently not supported)**

Known dates are exact dates that the user typically knows of the top of their head, such as birth
dates, credit card expiry dates...

Calendars are not suitable due to the usually bad default/initial value. Preferably they are able to
enter the numeric value for day, month and year, leveraging autocomplete as well.

On mobile devices, you'd typically want to use the native date widget too.

### Datepicker/calendar

The datepicker/calendar is suitable for nearby dates. We aim to make it accessible to assistive
technology and keyboard-only navigation.

Known issues/enhancements:

- Use arrow keys to navigate inside calendar
- Selecting a date in the next/previous month has some odd behaviour at the moment

<Canvas>
  <Story
    name="Datepicker"
    args={{
      name: 'test',
      label: 'A nearby date',
      description: 'Yarp',
      disabled: false,
      isRequired: false,
      minDate: undefined,
      maxDate: undefined,
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

<Canvas>
  <Story
    name="Limited range datepicker"
    play={async ({canvasElement}) => {
      const canvas = within(canvasElement);
      // calendar is by default not visible, until you focus the field
      await expect(await canvas.queryByRole('dialog')).toBeNull();
      await userEvent.click(canvas.getByText('A nearby date'));
      await expect(await canvas.findByRole('dialog')).toBeVisible();
      // ESC key closes the dialog again
      await userEvent.keyboard('[Escape]');
      await expect(await canvas.queryByRole('dialog')).toBeNull();
    }}
    args={{
      name: 'test',
      label: 'A nearby date',
      description: 'Yarp',
      disabled: false,
      isRequired: false,
      minDate: subDays(new Date(), 3),
      maxDate: addDays(new Date(), 3),
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

<Canvas>
  <Story
    name="Datepicker with disabled dates"
    play={async ({canvasElement}) => {
      const canvas = within(canvasElement);
      // calendar is by default not visible, until you focus the field
      await expect(await canvas.queryByRole('dialog')).toBeNull();
      await userEvent.click(canvas.getByText('Today disabled'));
      await expect(await canvas.findByRole('dialog')).toBeVisible();
      // today should be set to disabled
      const disabledEventButton = canvas.getByRole('button', {name: 'zaterdag 20 mei 2023'});
      await expect(disabledEventButton).toBeVisible();
      await expect(disabledEventButton).toHaveClass('utrecht-button--disabled');
      await expect(disabledEventButton).toBeDisabled();
    }}
    parameters={{
      formik: {
        initialValues: {
          test: '2023-05-31',
        },
      },
    }}
    args={{
      name: 'test',
      label: 'Today disabled',
      description: 'Yarp',
      disabled: false,
      isRequired: false,
      disabledDates: ['2023-05-20', new Date().toISOString(), addDays(new Date(), 3).toISOString()],
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

#### Interaction stories

<Canvas>
  <Story
    name="Datepicker - keyboard navigation"
    play={async ({canvasElement}) => {
      const canvas = within(canvasElement);
      // calendar is by default not visible, until you focus the field
      await expect(await canvas.queryByRole('dialog')).toBeNull();
      await userEvent.click(canvas.getByText('A nearby date'));
      await expect(await canvas.findByRole('dialog')).toBeVisible();
      // ESC key closes the dialog again
      await userEvent.keyboard('[Escape]');
      await expect(await canvas.queryByRole('dialog')).toBeNull();
    }}
    args={{
      name: 'test',
      label: 'A nearby date',
      description: 'Yarp',
      disabled: false,
      isRequired: false,
      minDate: undefined,
      maxDate: undefined,
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

<Canvas>
  <Story
    name="Datepicker - type date manually"
    play={async ({canvasElement}) => {
      const canvas = within(canvasElement);
      await expect(await canvas.queryByRole('dialog')).toBeNull();
      const textInput = canvas.getByLabelText('A nearby date');
      await userEvent.type(textInput, '2023-05-29');
      await expect(await canvas.queryByRole('dialog')).toBeNull();
      await expect(textInput).toHaveDisplayValue('2023-05-29');
      // check that the date is properly highlighted
      await userEvent.click(textInput);
      await expect(await canvas.findByRole('dialog')).toBeVisible();
      const selectedEventButton = canvas.getByRole('button', {name: 'maandag 29 mei 2023'});
      await expect(selectedEventButton).toBeVisible();
      await expect(selectedEventButton).toHaveClass(
        'utrecht-calendar__table-days-item-day--selected'
      );
    }}
    args={{
      name: 'test',
      label: 'A nearby date',
      description: 'Yarp',
      disabled: false,
      isRequired: false,
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

## Props

<ArgsTable of={DateField} />

## References

- https://design-system.service.gov.uk/patterns/dates/
- https://medium.com/samsung-internet-dev/making-input-type-date-complicated-a544fd27c45a
- https://github.com/nl-design-system/backlog/issues/189
- https://github.com/nl-design-system/backlog/issues/188
- https://github.com/nl-design-system/backlog/issues/35#issuecomment-1547704753

## No asterisks

The backend can be configured to treat fields as required by default and instead mark optional
fields explicitly.

<Canvas>
  <Story
    name="No asterisk for required"
    decorators={[ConfigDecorator]}
    parameters={{
      config: {
        requiredFieldsWithAsterisk: false,
      },
    }}
    args={{
      name: 'test',
      label: 'Default required',
      isRequired: true,
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>
