import {ArgsTable, Canvas, Meta, Story} from '@storybook/addon-docs';
import {expect} from '@storybook/jest';
import {userEvent, within} from '@storybook/testing-library';

import {FormikDecorator} from 'story-utils/decorators';

import NumberField from './NumberField';

export const Template = args => <NumberField {...args} />;
const generalTest = async canvasElement => {
  const canvas = within(canvasElement);
  await expect(canvas.getByLabelText('Amount')).toBeVisible();
  await expect(canvas.getByText('Amount')).toBeVisible();
  await expect(canvas.getByText('This is a custom description for the amount field')).toBeVisible();
  const input = canvas.getByRole('textbox');
  await expect(canvas.getByLabelText('Amount')).toBe(input);
  // Assert that you're not able to type letters
  userEvent.click(input);
  userEvent.type(input, 'abc');
  await expect(input).toHaveDisplayValue('4');
  // Assert that clicking on the label focuses the input
  const label = canvas.getByText('Amount');
  userEvent.click(label);
  await expect(canvas.getByRole('textbox')).toHaveFocus();
};

<Meta
  title="Pure React Components / Forms / NumberField"
  component={NumberField}
  decorators={[FormikDecorator]}
  parameters={{
    docs: {
      source: {
        type: 'dynamic',
        excludeDecorators: true,
      },
    },
    formik: {
      initialValues: {
        amount: '4',
      },
    },
  }}
/>

# Number inputs

Numeric inputs are essential for some types of data, but using the correct inputs is rather hard due
to a couple of reasons:

- some data looks numeric, but actually isn't
- associated validations (minimum and maximum values)
- accessibility concerns (especially when silently truncating or ignoring data)
- localisation - different locales use different decimal separators

The implementation of our `Number` component attempts to address these, and has taken certain
sources into account when doing so:

- https://technology.blog.gov.uk/2020/02/24/why-the-gov-uk-design-system-team-changed-the-input-type-for-numbers/

## SSN, Credit card, phone numbers...

Do not use the `NumberField` for these, instead use a `TextField`, possibly with
`inputmode="numeric"` and `pattern=[0-9]+` props.

This kind of data are actually just text inputs/strings that happen to consist only of digits. As a
rule of thumb, if leading zeroes are significant, you should use a `TextField` instead.

## Small number inputs

When you expect small, incremental values for numbers (such as number of attendees or products), you
can use this variant by specyfing the `useNumberType` boolean prop. This results in increment/
decrement buttons being exposed to the user so they don't need to type in the value.

This works well together with the `min` prop to specify a minimum value and `step` to specify the
increment/decrement step. E.g. to cycle between positive integers, you would use `min={1} step={1}`.

**Warning**

The HTML input does not prevent people from typing in invalid values (such as negative numbers or
decimals). You need to address this with input validators at the form level and display the
appropriate validation error(s).

(Silently) truncating user input (like a minus sign or decimal separator) is confusing, and for
users of assistive technology even worse as they have no feedback on what is actually
accepted/displayed on the screen.

<Canvas>
  <Story
    name="Small numbers with incr/decr buttons"
    args={{
      name: 'amount',
      id: 'amount-type-number',
      label: 'Amount',
      description: 'HTML type=number, still allows typing invalid values.',
      useNumberType: true,
      disabled: false,
      isRequired: false,
    }}
    play={async ({canvasElement}) => {
      const canvas = within(canvasElement);
      const input = canvas.getByLabelText('Amount');
      // assert that we can still type 'large' numbers
      await userEvent.clear(input);
      await userEvent.type(input, '1000');
      await expect(input).toHaveDisplayValue('1000');
      // assert that we can type floats without localisation
      await userEvent.clear(input);
      await userEvent.type(input, '1.5');
      await expect(input).toHaveDisplayValue('1.5');
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

## Free form number fields

Free form number inputs allow entering arbitrary numbers - decimals, negative, large, small... They
take the current locale into account and present formatted numbers. E.g. in the NL locale, the `.`
decimal separator will be converted to a comma, while thousand groups are automatically formatted
with a period.

Only numerical keyboard entries are allowed.

**TODO**: check accessibility impact of this!

The developer/form designers are responsible for defining validation rules for the values to express
minimum/maximum values.

**Notes**

- Props like `min` and `step` are ignored as they only apply to the `type="number"` inputs.

- The interaction tests rely on the NL locale. TODO: figure out how to change the locale in play
  functions.

<Canvas>
  <Story
    name="Default"
    args={{
      name: 'amount',
      id: 'amount',
      label: 'Amount',
      description: 'This is a custom description for the amount field',
      disabled: false,
      isRequired: false,
      useNumberType: false,
      min: undefined,
      step: undefined,
    }}
    parameters={{
      formik: {
        initialValues: {amount: ''},
      },
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

<Canvas>
  <Story
    name="Small localised numbers with decimals"
    play={async ({canvasElement}) => {
      await generalTest(canvasElement);
      const canvas = within(canvasElement);
      const input = canvas.getByLabelText('Amount');
      // Assert that you're able to provide a negative number
      userEvent.clear(input);
      userEvent.type(input, '-1');
      await expect(input).toHaveDisplayValue('-1');
      // Assert that you're able to provide a decimal number
      userEvent.clear(input);
      userEvent.type(input, '1.5');
      await expect(input).toHaveDisplayValue('1,5');
      // Assert that you're able to provide a decimal number with comma
      userEvent.clear(input);
      userEvent.type(input, '-2,3');
      await expect(input).toHaveDisplayValue('-2,3');
    }}
    args={{
      name: 'amount',
      id: 'amount',
      label: 'Amount',
      description: 'This is a custom description for the amount field',
      disabled: false,
      isRequired: true,
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

<Canvas>
  <Story
    name="Large localised numbers with thousand separator"
    play={async ({canvasElement}) => {
      await generalTest(canvasElement);
      const canvas = within(canvasElement);
      const input = canvas.getByLabelText('Amount');
      // Assert that you're able to provide a negative number
      userEvent.clear(input);
      userEvent.type(input, '10000');
      await expect(input).toHaveDisplayValue('10.000');
    }}
    args={{
      name: 'amount',
      id: 'amount',
      label: 'Amount',
      description: 'This is a custom description for the amount field',
      disabled: false,
      isRequired: true,
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

## Props

<ArgsTable of={NumberField} />

## Validation errors

<Canvas>
  <Story
    name="Validation error"
    parameters={{
      formik: {
        initialValues: {
          amount: 42,
        },
        initialErrors: {
          amount: 'invalid',
        },
      },
    }}
    args={{
      name: 'amount',
      label: 'Amount',
      description: 'Description above the errors',
      disabled: false,
      isRequired: true,
      useNumberType: false,
      min: undefined,
      step: undefined,
    }}
    play={async ({canvasElement}) => {
      const canvas = within(canvasElement);
      await expect(canvas.getByText('invalid')).toBeVisible();
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>
