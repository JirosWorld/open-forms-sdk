import {ArgsTable, Canvas, Meta, Story} from '@storybook/addon-docs';
import {expect} from '@storybook/jest';
import {userEvent, within} from '@storybook/testing-library';
import {useCallback} from 'react';

import {FormikDecorator} from 'story-utils/decorators';

import AsyncSelectField from './AsyncSelectField';
import SelectField from './SelectField';

export const delay = async delay => await new Promise(resolve => setTimeout(resolve, delay));

<Meta
  title="Pure React Components / Forms / SelectField"
  component={SelectField}
  decorators={[FormikDecorator]}
  parameters={{
    docs: {
      source: {
        type: 'dynamic',
        excludeDecorators: true,
      },
    },
    formik: {
      initialValues: {
        select: 'option-1',
      },
    },
  }}
/>

# Select Field

Use the `SelectField` component whenever you have `options` that are known upfront. If your options
are retrieved from some external data source (like an API endpoint) instead, use the
`AsyncSelectField` variant.

## SelectField

export const Template = args => <SelectField {...args} />;

<Canvas>
  <Story
    name="Static"
    args={{
      name: 'select',
      id: 'select-static',
      label: 'Static options',
      description: 'This is a custom description for the select field',
      disabled: false,
      isRequired: true,
      options: [
        {value: 'option-1', label: 'Option 1'},
        {value: 'option-2', label: 'Option 2'},
      ],
    }}
    parameters={{
      formik: {
        initialValues: {
          select: '',
        },
      },
    }}
    play={async ({canvasElement}) => {
      const canvas = within(canvasElement);
      const dropdown = canvas.getByLabelText('Static options');
      await expect(dropdown).toBeVisible();
      await expect(
        canvas.getByText('This is a custom description for the select field')
      ).toBeVisible();
      await expect(dropdown.role).toBe('combobox');
      // test that a value can be selected
      await expect(canvas.queryByText('Option 1')).toBeNull();
      await dropdown.focus();
      await userEvent.keyboard('[ArrowDown]');
      await expect(canvas.getByText('Option 1')).toBeVisible();
      await expect(canvas.getByText('Option 2')).toBeVisible();
      await userEvent.click(canvas.getByText('Option 2'));
      await expect(canvas.getByText('Option 2')).toBeVisible();
      await expect(canvas.queryByText('Option 1')).toBeNull();
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

<Canvas>
  <Story
    name="Force menu open"
    args={{
      name: 'select',
      id: 'select-static',
      label: 'Static options',
      description: 'This is a custom description for the select field',
      disabled: false,
      isRequired: true,
      options: [
        {value: 'option-1', label: 'Option 1'},
        {value: 'option-2', label: 'Option 2'},
      ],
      menuIsOpen: true,
    }}
    parameters={{
      formik: {
        initialValues: {
          select: '',
        },
      },
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

### Props

The select field is built on top of [react-select](https://react-select.com/). Any additional props
passed to our `SelectField` component are forwarded to the library's `Select` component.

<ArgsTable of={SelectField} />

## AsyncSelectField

When using this component, provide an `optionsRetriever` callback that will be used to retrieve the
options. This callback should be an async function returning an array of options.

The callback is passed to `useAsync` in the `react-use` library. You should properly wrap the
callback in `useCallback` to prevent excessive fetches/API calls.

export const DynamicTemplate = ({getOptionsDelay, dynamicOptions, ...args}) => {
  const getOptions = useCallback(async () => {
    await delay(getOptionsDelay);
    return dynamicOptions;
  }, [JSON.stringify(dynamicOptions), getOptionsDelay]);
  return <AsyncSelectField {...args} getOptions={getOptions} />;
};

<Canvas>
  <Story
    name="Async"
    args={{
      name: 'select',
      id: 'select-dynamic',
      label: 'Dynamic options',
      description: 'This is a custom description for the select field',
      disabled: false,
      isRequired: true,
      getOptionsDelay: 1000,
      dynamicOptions: [
        {value: 'daffy', label: 'Daffy'},
        {value: 'bugs', label: 'Bugs'},
        {value: 'elmer', label: 'Elmer'},
      ],
    }}
    argTypes={{
      options: {table: {disable: true}},
    }}
    play={async ({canvasElement, args}) => {
      const canvas = within(canvasElement);
      const dropdown = canvas.getByLabelText('Dynamic options');
      await expect(dropdown).toBeVisible();
      await expect(
        canvas.getByText('This is a custom description for the select field')
      ).toBeVisible();
      await expect(dropdown.role).toBe('combobox');
      // initially, in the loading state the options should not be visible
      await dropdown.focus();
      await userEvent.keyboard('[ArrowDown]');
      await expect(canvas.queryByText('Daffy')).toBeNull();
      await expect(canvas.queryByText('Bugs')).toBeNull();
      await expect(canvas.queryByText('Elmer')).toBeNull();
      await delay(args.getOptionsDelay + 5); // wait to resolve
      await expect(canvas.getByText('Daffy')).toBeVisible();
    }}
  >
    {DynamicTemplate.bind({})}
  </Story>
</Canvas>

### Props

All the props of `SelectField` itself are supported, and any additional props passed to
`AsyncSelectField` are forwarded to the underlying `SelectField`.

The `AsyncSelectField` requires the `getOptions` prop to populate the options.

<ArgsTable of={AsyncSelectField} />

## Validation errors

<Canvas>
  <Story
    name="Validation error"
    parameters={{
      formik: {
        initialValues: {
          invalidSelect: '',
        },
        initialErrors: {
          invalidSelect: 'invalid',
        },
      },
    }}
    args={{
      name: 'invalidSelect',
      label: 'Invalid select',
      description: 'Description above the errors',
      disabled: false,
      isRequired: false,
      options: [
        {value: 'option-1', label: 'Option 1'},
        {value: 'option-2', label: 'Option 2'},
      ],
    }}
    play={async ({canvasElement}) => {
      const canvas = within(canvasElement);
      await expect(canvas.getByText('invalid')).toBeVisible();
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>
