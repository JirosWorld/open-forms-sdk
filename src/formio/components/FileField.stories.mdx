import {ArgsTable, Canvas, Meta, Story} from '@storybook/addon-docs';
import {getWorker} from 'msw-storybook-addon';
import { within, userEvent } from '@storybook/testing-library';
import {expect} from '@storybook/jest';

export const worker = getWorker();

import {FileField} from './FileField';
import {
  UPLOAD_URL,
  mockFileUploadDelete,
  mockFileUploadErrorPost,
  mockFileUploadPost,
} from './FileUpload.mocks';
import {FormDecorator, FormioComponent} from './story-util';

export const FILEPATTERN = [
  'application/pdf',
  'application/msword',
  'application/vnd.rar',
  'application/zip',
  'image/heic',
  'image/jpeg',
  'image/png',
  'text/csv',
  'text/plain',
];

export const MIME_TO_LABEL = {
  'application/pdf': '.pdf',
  'application/msword': '.doc',
  'application/vnd.rar': '.rar',
  'application/zip': '.zip',
  'image/heic': '.heic',
  'image/jpeg': '.jpeg',
  'image/png': '.png',
  'text/csv': '.csv',
  'text/plain': '.txt',
}

export const ERRORS = ['File is too big', 'File is of the wrong type'];

<Meta
  title="Form.io components/FileUpload"
  component={FileField}
  argTypes={{
    filePattern: {
      options: FILEPATTERN,
      control: {type: 'check'},
    },
  }}
  decorators={[FormDecorator]}
  parameters={{
    controls: {sort: 'requiredFirst'},
    msw: {
      handlers: [mockFileUploadPost, mockFileUploadDelete],
    },
  }}
/>

# File Upload

**Note** - file uploads on the Docs page will always error due to the way
the network mocking library works. Use the canvas instead.

export const Template = ({
  id,
  label,
  required,
  description,
  filePattern=[],
  multiple,
  backendErrors=[],
}) => {
  if (backendErrors.length) {
    worker.use(mockFileUploadErrorPost(backendErrors));
  }
  return (
    <FormioComponent
      component={{
        type: 'file',
        id: 'ef2k87',
        key: id,
        label,
        input: true,
        description,
        validate: {
          required,
        },
        multiple,
        filePattern: filePattern.join(','),
        storage: 'url',
        url: UPLOAD_URL,
        file: {
          type: filePattern,
          allowedTypesLabels: filePattern.map(pattern => MIME_TO_LABEL[pattern]),
        }
      }}
    />
  );
}

## Happy flow

<Canvas>
  <Story
    name="Happy flow"
    args={{
      id: 'fileUpload1',
      label: 'Attachment',
      description: 'Klik om een bestand te selecteren en in te zenden',
      required: false,
      multiple: false,
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

<ArgsTable story="Happy flow" />

## File type validation errors

By selecting a `filePattern` and uploading a file of different type, it is possible to see the
error raised when a user uploads a file of wrong type.

<Canvas>
  <Story
    name="One allowed file type"
    argTypes={{
      filePattern: {table: {disable: true}}, // Ideally would like a readonly, but it looks like it's not possible in SB yet.
    }}
    args={{
      id: 'fileUpload2',
      label: 'Attachment',
      description: 'Klik om een bestand te selecteren en in te zenden. Alleen PDFs zijn toegestaan.',
      required: false,
      multiple: false,
      filePattern: ['application/pdf']
    }}
    play={async ({canvasElement}) => {
      const canvas = within(canvasElement);
      // Click on browse to make the input node injected in the dom
      const browseLink = canvas.getByRole('link', {name: 'browse'});
      await userEvent.click(browseLink); // This opens the file dialog, but without it the input node is not injected into the DOM
      // Upload a file of the wrong type
      const file = new File(['not-a-pdf'], 'not-a-pdf.png', {type: 'image/png'});
      const inputfile = document.querySelectorAll('.openforms-file-upload-input');
      await userEvent.upload(inputfile[0], file);
      // Check that the error message is there
      const errorMessage = canvas.getByText('The uploaded file is not of an allowed type. It must be: .pdf.');
      await expect(errorMessage).toBeVisible();
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

<Canvas>
  <Story
    name="Multiple allowed file types"
    argTypes={{
      filePattern: {table: {disable: true}},
    }}
    args={{
      id: 'fileUpload2',
      label: 'Attachment',
      description: 'Klik om een bestand te selecteren en in te zenden. Alleen PDFs en PNGs zijn toegestaan.',
      required: false,
      multiple: false,
      filePattern: ['application/pdf', 'image/png']
    }}
    play={async ({canvasElement}) => {
      const canvas = within(canvasElement);
      // Click on browse to make the input node injected in the dom
      const browseLink = canvas.getByRole('link', {name: 'browse'});
      await userEvent.click(browseLink);
      // Upload a file of the wrong type
      const file = new File(['not-a-pdf-or-png'], 'not-a-pdf-or-png.txt', {type: 'text/plain'});
      const inputfile = document.querySelectorAll('.openforms-file-upload-input');
      await userEvent.upload(inputfile[0], file);
      // Check that the error message is there
      const errorMessage = canvas.getByText('The uploaded file is not of an allowed type. It must be: .pdf or .png.');
      await expect(errorMessage).toBeVisible();
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

## Error flow

The backend performs a number of checks on file uploads and may return validation
errors. These are displayed on the upload component.

<Canvas>
  <Story
    name="Error flow"
    argTypes={{
      filePattern: {table: {disable: true}},
    }}
    args={{
      id: 'fileUpload2',
      label: 'Attachment',
      description: '',
      required: false,
      multiple: false,
      backendErrors: ['A dangerous virus was detected!'],
    }}
  >
    {Template.bind({})}
  </Story>
</Canvas>

<ArgsTable story="Error flow" />
